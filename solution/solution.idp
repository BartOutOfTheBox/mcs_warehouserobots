/** 
* Skeleton for the second part of the project. 
*
* No names in this skeleton can be changed, you can add things to the vocabulary and you should definitely add stuff to the theory. 
*/

include<LTC>

LTCvocabulary warehousevoc{
	type Time
	Start: Time
	partial Next(Time):Time

	type pallet
	type action constructed from {rotateRight, rotateLeft, moveFront, moveBack, pickUp(pallet), putDown(pallet)}	
	execute(Time,action)

	on(Time,pallet,pallet)
	carried(Time,pallet)

	type xco isa nat
	type yco isa nat	
	type location constructed from {grid(xco,yco)}
	inaccessible(location)
	robotposition(Time): location
	position(Time,pallet): location
	
	type dir constructed from {north, east, south, west}
	facing(Time): dir
	
	type height isa nat
	ceiling: height
	
	// above(p1,p2) means p1 is located above p2. 
	// (eg. if on(p1,p3) & on(p3,p2) then above(p1,p3) & above (p3,p2) & above (p1,p2))
	above(Time, pallet,pallet)
    
	// Each pallet is located on a certain height.
	// The top of the pallet counts as the point of height.
	// A pallet standing on the floor thus has height 1.
	heightOf(Time, pallet): height
}

theory solution: warehousevoc{
	// Inaccessible positions are inaccessible for robots.
	! l [location], t [Time]: inaccessible(l) => (robotposition(t) ~= l).
    
	// Inaccessible positions are inaccessible for pallets.
	! l [location], p [pallet], t [Time]: inaccessible(l) => (position(t, p) ~= l).
    
	// The robot can carry no more than one pallet at a time, hence:
	// If both pallet1 and pallet2 are carried by the robot, pallet1 and pallet2 are the same pallet.
	! p1 [pallet], p2 [pallet], t [Time]: (carried(t, p1) & carried(t, p2)) => p1 = p2.
    
	// The robot cannot stand on a stack of pallets, hence, pallets only have the same position as the robot 
	// when they are being carried by the robot.
	! p [pallet], t [Time]:  carried(t, p) <=> (position(t, p) = robotposition(t)).
    
	// Helper for the next expression. a pallet p1 is above another pallet p2 if above(p1,p2). 
	// There may or may not be other pallets in between.
	{
		! p1 [pallet], p2 [pallet], t [Time]: above(t,p1,p2) <- on(t,p1,p2).
		! p1 [pallet], p2 [pallet], p3 [pallet], t [Time]: 
			above(t,p1,p3) <- above(t,p1,p2) & above(t,p2,p3).
	}
    
	// It cannot be the case that pallet p1 is above pallet p2 and at the same time pallet p2 is above p1.
	// Therefore pallet p1 cannot rest on pallet p2 if pallet p2 rests on pallet p1.
	! p1 [pallet], p2 [pallet], t [Time]: above(t,p1,p2) => (~above(t,p2,p1)).
    
	// At most one other pallet resting on every other pallet.
	// Hence if two pallets are resting on the same pallet, the former two are actually the same pallet.
	! p1 [pallet], p2 [pallet], p3 [pallet], t [Time]: (on(t,p1,p3) & on(t,p2,p3)) => (p1 = p2).
    
	// Height pallet - 1: The amount of pallets on the same position, which are not above this pallet.
	! p1 [pallet], t [Time]: heightOf(t,p1) = 
		#{p2 [pallet]: (position(t,p1) = position(t,p2)) & (~above(t,p2, p1))} + 1.
    
	// Stacks of pallets are limited in height by the ceiling of the warehouse.
	! p [pallet], t [Time]: heightOf(t,p) =< ceiling.
	
	// Pallets on top of each other, have to have the same location.
	! p1 [pallet], p2 [pallet], t [Time]: on(t,p1,p2) => (position(t,p1) = position(t,p2)).
	
	// At most one pallet resting on the floor on the same location.
	// Hence if two pallets are resting on the same location on the floor, these pallets are actually the same pallet.
	! p1 [pallet], p2 [pallet], t [Time]: ~above(t,p1,p2) & ~above(t,p2,p1) => (position(t,p1) ~= position(t,p2)).
}


theory verification1: warehousevoc{
	//Verify something here
}

procedure verification1proc(struc){
	//Do something here: verify verification1 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

theory verification2: warehousevoc{
	//Verify something here
}

procedure verification2proc(struc){
	//Do something here: verify verification2 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

theory verification3: warehousevoc{
	//Verify something here
}

procedure verification3proc(struc){
	//Do something here: verify verification3 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}


procedure allVerifications(){
	strucToCheck = verStruc
	verification1proc(strucToCheck)
	verification2proc(strucToCheck)
	verification3proc(strucToCheck)
}


structure verStruc:warehousevoc{
	Time = {0..16}
	Start = 0
	Next = {0->1;1->2;2->3;3->4;4->5;5->6;6->7;7->8;8->9;9->10;10->11;11->12;12->13;13->14;14->15;15->16}
	xco={1..3}
	yco={1..3}
	height = {0..3}
	pallet={p1;p2}
	inaccessible={grid(3,2);grid(2,2)}
	ceiling = 3
}


procedure main(){
    //Depending on what you wish to do, execute one of the following methods:
	 
    //This method (defined in the instances.idp) checks some given worlds for consistency
	check()

    //This method lets you walk through your solutions interactively
	simulate_interactive(solution,verStruc)
	
    //This method walks randomly trough the solutions, 5 steps deep
	simulate_random(solution,verStruc,5)
	
    //This method (defined above) simply searches models of your theory
	stdoptions.nbmodels=5 //Find 5 models	
	printmodels(modelexpand(solution,verStruc))
	
}
