/** 
* Skeleton for the second part of the project. 
*
* No names in this skeleton can be changed, you can add things to the vocabulary and you should definitely add stuff to the theory. 
*/

include<LTC>

LTCvocabulary warehousevoc{
	type Time
	Start: Time
	partial Next(Time):Time

	type pallet
	type action constructed from {rotateRight, rotateLeft, moveFront, moveBack, pickUp(pallet), putDown(pallet)}	
	execute(Time,action)

	on(Time,pallet,pallet)
	// Helper predicates
	I_on(pallet,pallet)	// Initial
	C_on(Time,pallet,pallet)	// Causes
	Cn_on(Time,pallet,pallet)	// Causes not
	
	carried(Time,pallet)
	// Helper predicates
	I_carried(pallet)	// Initial
	C_carried(Time,pallet)	// Causes
	Cn_carried(Time,pallet)	// Causes not

	type xco isa nat
	type yco isa nat	
	type location constructed from {grid(xco,yco)}
	inaccessible(location)
	
	robotposition(Time): location
	
	// Helper predicates
	I_robotposition(location)		// Initial
	C_robotposition(Time,location)	// Causes
	Cn_robotposition(Time,location)	// Causes not
	
	position(Time,pallet): location
	
	// Helper predicates
	I_position(pallet,location)			// Initial
	C_position(Time,pallet,location)	// Causes
	Cn_position(Time,pallet,location)	// Causes not
	
	
	type dir constructed from {north, east, south, west}
	facing(Time): dir
	
	type height isa nat
	ceiling: height
	
	// above(p1,p2) means p1 is located above p2. 
	// (eg. if on(p1,p3) & on(p3,p2) then above(p1,p3) & above (p3,p2) & above (p1,p2))
	above(Time, pallet,pallet)
    
	// Each pallet is located on a certain height.
	// The top of the pallet counts as the point of height.
	// A pallet standing on the floor thus has height 1.
	heightOf(Time, pallet): height
}

theory solution: warehousevoc{
	// Inaccessible positions are inaccessible for robots.
	! l [location], t [Time]: inaccessible(l) => (robotposition(t) ~= l).
    
	// Inaccessible positions are inaccessible for pallets.
	! l [location], p [pallet], t [Time]: inaccessible(l) => (position(t, p) ~= l).
    
	// The robot can carry no more than one pallet at a time, hence:
	// If both pallet1 and pallet2 are carried by the robot, pallet1 and pallet2 are the same pallet.
	! p1 [pallet], p2 [pallet], t [Time]: (carried(t, p1) & carried(t, p2)) => p1 = p2.
    
	// The robot cannot stand on a stack of pallets, hence, pallets only have the same position as the robot 
	// when they are being carried by the robot.
	! p [pallet], t [Time]:  carried(t, p) <=> (position(t, p) = robotposition(t)).
    
	// Helper for the next expression. a pallet p1 is above another pallet p2 if above(p1,p2). 
	// There may or may not be other pallets in between.
	{
		! p1 [pallet], p2 [pallet], t [Time]: above(t,p1,p2) <- on(t,p1,p2).
		! p1 [pallet], p2 [pallet], p3 [pallet], t [Time]: 
			above(t,p1,p3) <- above(t,p1,p2) & above(t,p2,p3).
	}
    
	// It cannot be the case that pallet p1 is above pallet p2 and at the same time pallet p2 is above p1.
	// Therefore pallet p1 cannot rest on pallet p2 if pallet p2 rests on pallet p1.
	! p1 [pallet], p2 [pallet], t [Time]: above(t,p1,p2) => (~above(t,p2,p1)).
    
	// At most one other pallet resting on every other pallet.
	// Hence if two pallets are resting on the same pallet, the former two are actually the same pallet.
	! p1 [pallet], p2 [pallet], p3 [pallet], t [Time]: (on(t,p1,p3) & on(t,p2,p3)) => (p1 = p2).
    
	// Height pallet - 1: The amount of pallets on the same position, which are not above this pallet.
	! p1 [pallet], t [Time]: heightOf(t,p1) = 
		#{p2 [pallet]: (position(t,p1) = position(t,p2)) & (~above(t,p2, p1))} + 1.
    
	// Stacks of pallets are limited in height by the ceiling of the warehouse.
	! p [pallet], t [Time]: heightOf(t,p) =< ceiling.
	
	// Pallets on top of each other, have to have the same location.
	! p1 [pallet], p2 [pallet], t [Time]: on(t,p1,p2) => (position(t,p1) = position(t,p2)).
	
	// At most one pallet resting on the floor on the same location.
	// Hence if two pallets are resting on the same location on the floor, these pallets are actually the same pallet.
	! p1 [pallet], p2 [pallet], t [Time]: ~above(t,p1,p2) & ~above(t,p2,p1) => (position(t,p1) ~= position(t,p2)).
}

theory timeTheo:V{
	{
		Start = MIN[:Time].
		!t: Next(t) = t+1 <- Time(t+1).
	}
}

theory dynTheo:V{
	{ 
		// Successor State Action Axiom & Inertia on(Time,pallet,pallet)
		! p1 [pallet], p2 [pallet]: on(Start,p1,p2) <- I_on(p1,p2).
		! p1 [pallet], p2 [pallet], t [Time]: 
			on(Next(t),p1,p2) <- C_on(t,p1,p2).
		! p1 [pallet], p2 [pallet], t [Time]: 
			on(Next(t),p1,p2) <- on(t,p1,p2) & ~Cn_on(t,p1,p2).
	}
	
	{
		// Expressing causations on(Time,pallet,pallet)
		//TODO
		! p1 [pallet], p2 [pallet], t [Time] : 
			C_on(t,p1,p2) <- ? p1 : 
				execute(t,putDown(p1)) & .
		! p b t : Cn_on(p,b,t) <- ? p2 : Give(p, b, p2, t).
	}
	
	{
		// Successor State Action Axiom & Inertia carried(Time,pallet)
		! p [pallet]: carried(Start,p) <- I_carried(p).
		! p [pallet], t [time]: carried(Next(t),p) <- C_carried(t,p).
		! p [pallet], t [time]: 
			carried(Next(t),p) <- carried(t,p) & ~Cn_carried(t,p).	
	}
	
	{
		// Expressing causations carried(Time,pallet)
		//TODO
	}
	
	{
		// Successor State Action Axiom & Inertia robotposition(Time):location
		! l [location]: robotposition(Start) = l <- I_robotposition(l).
		! l [location], t [Time]: 
			robotposition(Next(t)) = l <- C_robotposition(t,l).
		! l [location], t [Time]: 
			robotposition(Next(t)) = 
				l <- (robotposition(t) = l) & ~Cn_robotposition(t,l).
	}
	
	{
		// Expressing causations robotposition(Time):location
		// Facing north and going forwards
		! l [location], t [Time] : 
			C_robotposition(t,l) <- 
				(facing(t) = north) &
				(execute(t,moveFront) &
				(? l1 [location] : l1(x,y) & l(x,y+1)).
		// Facing north and going backwards
		! l [location], t [Time] : 
			C_robotposition(t,l) <- 
				(facing(t) = north) &
				(execute(t,moveBack) &
				(? l1 [location] : l1(x,y) & l(x,y-1)).
		// Facing south and going forwards
		! l [location], t [Time] : 
			C_robotposition(t,l) <- 
				(facing(t) = south) &
				(execute(t,moveFront) &
				(? l1 [location] : l1(x,y) & l(x,y-1)).
		// Facing south and going backwards
		! l [location], t [Time] : 
			C_robotposition(t,l) <- 
				(facing(t) = south) &
				(execute(t,moveBack) &
				(? l1 [location] : l1(x,y) & l(x,y+1)).
		// Facing east and going forwards
		! l [location], t [Time] : 
			C_robotposition(t,l) <- 
				(facing(t) = east) &
				(execute(t,moveFront) &
				(? l1 [location] : l1(x,y) & l(x+1,y)).
		// Facing east and going backwards.
		! l [location], t [Time] : 
			C_robotposition(t,l) <- 
				(facing(t) = east) &
				(execute(t,moveBack) &
				(? l1 [location] : l1(x,y) & l(x-1,y)).
		// Facing west and going forwards
		! l [location], t [Time] : 
			C_robotposition(t,l) <- 
				(facing(t) = west) &
				(execute(t,moveFront) &
				(? l1 [location] : l1(x,y) & l(x-1,y)).
		// Facing west and going backwards
		! l [location], t [Time] : 
			C_robotposition(t,l) <- 
				(facing(t) = west) &
				(execute(t,moveBack) &
				(? l1 [location] : l1(x,y) & l(x+1,y)).
				
		// reason not to be on the same position is moving.
		! l [location], t [Time] :  
			Cn_robotposition(t,l) <- (robotposition(t) = l) &
										(execute(t,moveFront)).
		! l [location], t [Time] :  
			Cn_robotposition(t,l) <- (robotposition(t) = l) &
										(execute(t,moveBack)).
	}
	
	{
		// Successor State Action Axiom & Inertia position(Time,pallet):location
		! p [pallet], l [location]:	position(Start,p) = l <- I_position(p,l).
		! p [pallet], l [location], t [Time]:
			position(Next(t),p) = l <- C_position(t,p,l).
		! p [pallet], l [location], t [Time]:
			position(Next(t),p) = l <- 
				(position(t,p) = l) & ~Cn_position(t,p,l).
	}
	
	{
		// Expressing causations position(Time,pallet):location
		//TODO
		! l [location], p [pallet], t [Time] :
			C_position(t,p,l) <- 
				execute(t,putDown(p)) & (facing(t)=north) & (robotposition(t)=locr) & locr(x,y) & l(x,y+1).
		! l [location], p [pallet], t [Time] :
			C_position(t,p,l) <- 
				execute(t,putDown(p)) & (facing(t)=east) & (robotposition(t)=locr) & locr(x,y) & l(x+1,y).
		! l [location], p [pallet], t [Time] :
			C_position(t,p,l) <- 
				execute(t,putDown(p)) & (facing(t)=south) & (robotposition(t)=locr) & locr(x,y) & l(x,y-11).
		! l [location], p [pallet], t [Time] :
			C_position(t,p,l) <- 
				execute(t,putDown(p)) & (facing(t)=west) & (robotposition(t)=locr) & locr(x,y) & l(x-1,y).
				
		! l [location], p [pallet], t [Time] :  
			Cn_robotposition(t,l) <- execute(t,pickUp(p)).
	}
}


theory verification1: warehousevoc{
	//Verify something here
}

procedure verification1proc(struc){
	//Do something here: verify verification1 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

theory verification2: warehousevoc{
	//Verify something here
}

procedure verification2proc(struc){
	//Do something here: verify verification2 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}

theory verification3: warehousevoc{
	//Verify something here
}

procedure verification3proc(struc){
	//Do something here: verify verification3 in the context of structure struc. 
	//At least print whether the verification is satisified or not.
}


procedure allVerifications(){
	strucToCheck = verStruc
	verification1proc(strucToCheck)
	verification2proc(strucToCheck)
	verification3proc(strucToCheck)
}


structure verStruc:warehousevoc{
	Time = {0..16}
	Start = 0
	Next = {0->1;1->2;2->3;3->4;4->5;5->6;6->7;7->8;8->9;9->10;10->11;11->12;12->13;13->14;14->15;15->16}
	xco={1..3}
	yco={1..3}
	height = {0..3}
	pallet={p1;p2}
	inaccessible={grid(3,2);grid(2,2)}
	ceiling = 3
}


procedure main(){
    //Depending on what you wish to do, execute one of the following methods:
	 
    //This method (defined in the instances.idp) checks some given worlds for consistency
	check()

    //This method lets you walk through your solutions interactively
	simulate_interactive(solution,verStruc)
	
    //This method walks randomly trough the solutions, 5 steps deep
	simulate_random(solution,verStruc,5)
	
    //This method (defined above) simply searches models of your theory
	stdoptions.nbmodels=5 //Find 5 models	
	printmodels(modelexpand(solution,verStruc))
	
}
